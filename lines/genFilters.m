%%
%% Generate 2 * n + 1 symmetric directional Prewitt filters.
%% The filters are twice as high as the height of the EPI. And each 
%% successive filter is offset by one pixel along the top and bottom edge:
%%
%%        |--| <----This offset increases by one pixel for each successive filter
%%   ___________    The width of the filter is determined by the offset.
%%   |    : //  |  
%%   |    ://   |
%%   |    //    |
%%   |   //     |  Height = 2 * epiSz(1) + 1;
%%   |  //:     |
%%   | // :     |
%%   |//__:_____|
%%
%% The gradient of each filter along the x, and y directions is returned in gx,
%% and gy respectively.
%%
function [F, gx, gy] = genFilters(n, epiSz)

  h = 2 * epiSz(1) + 1;
  off = h/epiSz(1);
  w = 2 * ceil(n * off) + 1;
  midw = ceil(w/2);

  F = zeros(h, w, n * 2 - 1);
  gx = zeros(1, n * 2 - 1);
  gy = zeros(1, n * 2 - 1);

  for i = 1:n
    x = round([midw + (n - i) * off, midw - (n - i) * off]);

    bwPos = zeros(h, w);
    bwPos = insertShape(bwPos, 'line', [x(1)-1, 0, x(2) - 1 h]);
    bwPos = bwPos(:, :, 1);
    bwPos = bwPos / sum(sum(bwPos));

    bwNeg = zeros(h, w);
    bwNeg = insertShape(bwNeg, 'line', [x(1)+1, 0, x(2) + 1 h]);
    bwNeg = bwNeg(:, :, 1);
    bwNeg = (bwNeg / sum(sum(bwNeg))) .* -1;

    F(:, :, i) = bwNeg + bwPos;

    % calculate the gradients
    gn = 1 / sqrt( (h/2).^2 + (n - i).^2);
    gx(i) = -(h/2) .* gn;
    gy(i) = (n - i) .* gn;
  end

  % the next n filters are generated by flipping the existing ones
  F(:, :, n+1:end) = fliplr(F(:, :, n-1:-1:1)) .* -1; 
  gx(n+1:end) = gx(n-1:-1:1);
  gy(n+1:end) = -gy(n-1:-1:1);
end


